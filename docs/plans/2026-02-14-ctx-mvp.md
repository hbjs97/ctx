# ctx MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** ctx CLI 전체 MVP 구현 — GitHub 멀티계정 자동 판정, 잘못된 계정 push 차단, gh/git/ssh 컨텍스트 관리.

**Architecture:** 의존성 그래프 Bottom-up TDD: 인프라 정리 → 데이터(config, cache) → 어댑터(git, gh) → 코어(resolver) → 안전 계층(guard, shell, doctor) → CLI → 엔트리포인트. Commander interface로 외부 명령 추상화, 각 패키지 독립 테스트 가능.

**Tech Stack:** Go 1.26, `github.com/BurntSushi/toml` (TOML 파싱), `github.com/stretchr/testify` (테스트 assertions), `github.com/spf13/cobra` (CLI 프레임워크)

**Key Docs:**
- `docs/PRD.md` — 기능 요구사항 (FR-01~FR-14)
- `docs/TECH_SPEC.md` — 기술 스펙 (Resolver 5단계, Guard, GH Adapter)
- `docs/TESTING.md` — 테스트 전략 (3계층, table-driven, Commander mock)
- `.claude/rules/` — 코딩 컨벤션, 아키텍처, 보안, TDD 규칙

---

## Pre-Task: Commander Interface 추출

**문제:** `Commander` interface와 `RealCommander`가 `internal/testutil/`에 있다. 프로덕션 코드(git, gh, guard, doctor)가 testutil을 import하게 되어 의존성 방향이 잘못된다.

**해결:** `Commander` interface + `RealCommander`를 `internal/cmdexec/` 패키지로 추출. `FakeCommander`는 testutil에 유지.

**Files:**
- Create: `internal/cmdexec/cmdexec.go`
- Modify: `internal/testutil/exec.go` — Commander/RealCommander 제거, cmdexec import
- Modify: `internal/testutil/exec_test.go` — import 경로 변경

**Step 1: `internal/cmdexec/cmdexec.go` 생성**

```go
// Package cmdexec abstracts external command execution for testability.
package cmdexec

import (
	"context"
	"os/exec"
)

// Commander abstracts external command execution.
type Commander interface {
	Run(ctx context.Context, name string, args ...string) ([]byte, error)
}

// RealCommander executes actual external commands via os/exec.
type RealCommander struct{}

// Run executes the command using os/exec.CommandContext.
func (c *RealCommander) Run(ctx context.Context, name string, args ...string) ([]byte, error) {
	return exec.CommandContext(ctx, name, args...).CombinedOutput()
}
```

**Step 2: `internal/testutil/exec.go` 수정**

- `Commander` interface, `RealCommander` 삭제
- `FakeCommander`의 `Run` 시그니처가 `cmdexec.Commander`를 만족하도록 유지
- import 추가: `"github.com/hbjs97/ctx/internal/cmdexec"` (FakeCommander의 godoc에 참조용)

**Step 3: 기존 테스트 통과 확인**

Run: `go test ./internal/testutil/... -v`
Expected: all 6 tests PASS

**Step 4: Commit**

```bash
git add internal/cmdexec/ internal/testutil/
git commit -m "refactor: extract Commander interface to internal/cmdexec"
```

---

## Phase 1: 데이터 기반

### Task 1: 프로젝트 의존성 추가

**Files:**
- Modify: `go.mod`, `go.sum`

**Step 1: 의존성 추가**

```bash
go get github.com/BurntSushi/toml@v1
go get github.com/stretchr/testify
```

**Step 2: 빌드 확인**

Run: `go build ./...`
Expected: SUCCESS

**Step 3: Commit**

```bash
git add go.mod go.sum
git commit -m "chore: add toml and testify dependencies"
```

---

### Task 2: config 패키지 — 타입, Load, 기본값, 유효성 검증

config.toml 파싱, 필수 필드 검증, 기본값 적용, 파일 권한 확인.

**Files:**
- Create: `internal/config/config.go`
- Modify: `internal/config/example_test.go`

**Refs:** TECH_SPEC §5.1, security.md (파일 권한 0600)

**Step 1: 실패 테스트 — TestLoadConfig_ValidTOML**

`internal/config/example_test.go` 전체 교체:

```go
package config_test

import (
	"os"
	"testing"

	"github.com/hbjs97/ctx/internal/config"
	"github.com/hbjs97/ctx/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoadConfig_ValidTOML(t *testing.T) {
	content := `version = 1
default_profile = "personal"

[profiles.work]
gh_config_dir = "/home/test/.config/gh-work"
ssh_host = "github-work"
git_name = "Test User"
git_email = "test@company.com"
email_domain = "company.com"
owners = ["company-org", "company-team"]

[profiles.personal]
gh_config_dir = "/home/test/.config/gh-personal"
ssh_host = "github-personal"
git_name = "testuser"
git_email = "test@example.com"
email_domain = "example.com"
owners = ["testuser"]`

	path := testutil.TempConfigFile(t, content)
	cfg, err := config.Load(path)

	require.NoError(t, err)
	assert.Equal(t, 1, cfg.Version)
	assert.Equal(t, "personal", cfg.DefaultProfile)
	assert.True(t, cfg.PromptOnAmbiguous)
	assert.True(t, cfg.RequirePushGuard)
	assert.Equal(t, 90, cfg.CacheTTLDays)
	assert.Len(t, cfg.Profiles, 2)

	work := cfg.Profiles["work"]
	assert.Equal(t, "/home/test/.config/gh-work", work.GHConfigDir)
	assert.Equal(t, "github-work", work.SSHHost)
	assert.Equal(t, "Test User", work.GitName)
	assert.Equal(t, "test@company.com", work.GitEmail)
	assert.Equal(t, "company.com", work.EmailDomain)
	assert.Equal(t, []string{"company-org", "company-team"}, work.Owners)
}

func TestLoadConfig_MissingFile(t *testing.T) {
	_, err := config.Load("/nonexistent/path/config.toml")
	assert.Error(t, err)
}

func TestLoadConfig_InvalidTOML(t *testing.T) {
	path := testutil.TempConfigFile(t, "invalid toml [[[")
	_, err := config.Load(path)
	assert.Error(t, err)
}

func TestLoadConfig_MissingRequiredFields(t *testing.T) {
	tests := []struct {
		name    string
		content string
	}{
		{
			name: "no profiles",
			content: `version = 1`,
		},
		{
			name: "missing gh_config_dir",
			content: `version = 1
[profiles.work]
ssh_host = "h"
git_name = "n"
git_email = "e"
owners = ["o"]`,
		},
		{
			name: "missing git_email",
			content: `version = 1
[profiles.work]
gh_config_dir = "/tmp"
ssh_host = "h"
git_name = "n"
owners = ["o"]`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			path := testutil.TempConfigFile(t, tt.content)
			_, err := config.Load(path)
			assert.Error(t, err)
		})
	}
}

func TestLoadConfig_DefaultValues(t *testing.T) {
	content := `version = 1
[profiles.work]
gh_config_dir = "/tmp/gh"
ssh_host = "github-work"
git_name = "Test"
git_email = "t@t.com"
owners = ["org"]`

	path := testutil.TempConfigFile(t, content)
	cfg, err := config.Load(path)

	require.NoError(t, err)
	assert.True(t, cfg.PromptOnAmbiguous)
	assert.True(t, cfg.RequirePushGuard)
	assert.False(t, cfg.AllowHTTPSManagedRepo)
	assert.Equal(t, 90, cfg.CacheTTLDays)
}

func TestLoadConfig_ExplicitFalse(t *testing.T) {
	content := `version = 1
prompt_on_ambiguous = false
require_push_guard = false
cache_ttl_days = 30
[profiles.work]
gh_config_dir = "/tmp/gh"
ssh_host = "h"
git_name = "n"
git_email = "e"
owners = ["o"]`

	path := testutil.TempConfigFile(t, content)
	cfg, err := config.Load(path)

	require.NoError(t, err)
	assert.False(t, cfg.PromptOnAmbiguous)
	assert.False(t, cfg.RequirePushGuard)
	assert.Equal(t, 30, cfg.CacheTTLDays)
}

func TestValidateFilePermissions(t *testing.T) {
	path := testutil.TempConfigFile(t, `version = 1`)

	// 0600 — 경고 없음
	err := config.ValidateFilePermissions(path)
	assert.NoError(t, err)

	// 0644 — 경고
	os.Chmod(path, 0644)
	err = config.ValidateFilePermissions(path)
	assert.Error(t, err)
}
```

**Step 2: 실행 — 실패 확인**

Run: `go test ./internal/config/... -run TestLoadConfig_ValidTOML -v`
Expected: FAIL — `config.Load` undefined

**Step 3: 구현 — `internal/config/config.go`**

```go
package config

import (
	"crypto/sha256"
	"fmt"
	"os"
	"sort"

	"github.com/BurntSushi/toml"
)

// Config는 ctx 설정 파일의 최상위 구조체다.
type Config struct {
	Version               int                `toml:"version"`
	DefaultProfile        string             `toml:"default_profile"`
	PromptOnAmbiguous     *bool              `toml:"prompt_on_ambiguous"`
	RequirePushGuard      *bool              `toml:"require_push_guard"`
	AllowHTTPSManagedRepo bool               `toml:"allow_https_managed_repo"`
	CacheTTLDays          int                `toml:"cache_ttl_days"`
	Profiles              map[string]Profile  `toml:"profiles"`
}

// Profile은 하나의 GitHub 계정 프로필이다.
type Profile struct {
	GHConfigDir string   `toml:"gh_config_dir"`
	SSHHost     string   `toml:"ssh_host"`
	GitName     string   `toml:"git_name"`
	GitEmail    string   `toml:"git_email"`
	EmailDomain string   `toml:"email_domain"`
	Owners      []string `toml:"owners"`
}

// Load는 config.toml을 파싱하여 Config를 반환한다.
func Load(path string) (*Config, error) {
	var cfg Config
	if _, err := toml.DecodeFile(path, &cfg); err != nil {
		return nil, fmt.Errorf("config.Load: %w", err)
	}
	cfg.applyDefaults()
	if err := cfg.validate(); err != nil {
		return nil, err
	}
	return &cfg, nil
}

func (c *Config) applyDefaults() {
	if c.PromptOnAmbiguous == nil {
		t := true
		c.PromptOnAmbiguous = &t
	}
	if c.RequirePushGuard == nil {
		t := true
		c.RequirePushGuard = &t
	}
	if c.CacheTTLDays == 0 {
		c.CacheTTLDays = 90
	}
}

func (c *Config) validate() error {
	if len(c.Profiles) == 0 {
		return fmt.Errorf("config.Load: 프로필이 정의되지 않았습니다")
	}
	for name, p := range c.Profiles {
		if p.GHConfigDir == "" {
			return fmt.Errorf("config.Load: profiles.%s.gh_config_dir 필수", name)
		}
		if p.SSHHost == "" {
			return fmt.Errorf("config.Load: profiles.%s.ssh_host 필수", name)
		}
		if p.GitName == "" {
			return fmt.Errorf("config.Load: profiles.%s.git_name 필수", name)
		}
		if p.GitEmail == "" {
			return fmt.Errorf("config.Load: profiles.%s.git_email 필수", name)
		}
	}
	return nil
}

// ValidateFilePermissions는 파일 권한이 0600보다 넓으면 에러를 반환한다.
func ValidateFilePermissions(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("config.ValidateFilePermissions: %w", err)
	}
	perm := info.Mode().Perm()
	if perm&0077 != 0 {
		return fmt.Errorf("config.ValidateFilePermissions: %s 권한이 %o (0600 필요)", path, perm)
	}
	return nil
}
```

**주의:** `PromptOnAmbiguous`와 `RequirePushGuard`는 `*bool` 포인터 타입이다. TOML에서 명시적으로 `false`로 설정한 경우와 미설정을 구분하기 위함. 외부에서 접근 시 getter 메서드를 제공하거나, `IsPromptOnAmbiguous()` 같은 convenience 메서드를 추가한다:

```go
// IsPromptOnAmbiguous는 prompt_on_ambiguous 설정값을 반환한다.
func (c *Config) IsPromptOnAmbiguous() bool {
	if c.PromptOnAmbiguous == nil {
		return true
	}
	return *c.PromptOnAmbiguous
}

// IsRequirePushGuard는 require_push_guard 설정값을 반환한다.
func (c *Config) IsRequirePushGuard() bool {
	if c.RequirePushGuard == nil {
		return true
	}
	return *c.RequirePushGuard
}
```

테스트에서는 `cfg.IsPromptOnAmbiguous()` 사용. assert 수정 필요.

**Step 4: 테스트 통과 확인**

Run: `go test ./internal/config/... -v`
Expected: all PASS

**Step 5: Commit**

```bash
git add internal/config/config.go internal/config/example_test.go
git commit -m "feat(config): implement Load with TOML parsing, validation, defaults"
```

---

### Task 3: config 패키지 — Profile Store (MatchOwner, GetProfile, ConfigHash)

**Files:**
- Modify: `internal/config/config.go`
- Modify: `internal/config/example_test.go` (하단 Profile Store 테스트)

**Refs:** TECH_SPEC §6.3 (Owner 규칙), §5.2 (config_hash)

**Step 1: Profile Store 테스트 (example_test.go 하단에 추가)**

```go
func TestMatchOwner_SingleMatch(t *testing.T) {
	cfg := &config.Config{
		Profiles: map[string]config.Profile{
			"work":     {Owners: []string{"company-org", "company-team"}},
			"personal": {Owners: []string{"hbjs97", "sutefu23"}},
		},
	}
	matches := cfg.MatchOwner("company-org")
	assert.Equal(t, []string{"work"}, matches)
}

func TestMatchOwner_NoMatch(t *testing.T) {
	cfg := &config.Config{
		Profiles: map[string]config.Profile{
			"work": {Owners: []string{"company-org"}},
		},
	}
	matches := cfg.MatchOwner("unknown-org")
	assert.Empty(t, matches)
}

func TestMatchOwner_MultipleMatch(t *testing.T) {
	cfg := &config.Config{
		Profiles: map[string]config.Profile{
			"work":     {Owners: []string{"shared-org"}},
			"personal": {Owners: []string{"shared-org"}},
		},
	}
	matches := cfg.MatchOwner("shared-org")
	assert.Len(t, matches, 2)
}

func TestGetProfile_Exists(t *testing.T) {
	cfg := &config.Config{
		Profiles: map[string]config.Profile{
			"work": {GHConfigDir: "/tmp/gh-work", GitEmail: "w@co.com"},
		},
	}
	p, err := cfg.GetProfile("work")
	require.NoError(t, err)
	assert.Equal(t, "/tmp/gh-work", p.GHConfigDir)
}

func TestGetProfile_NotExists(t *testing.T) {
	cfg := &config.Config{Profiles: map[string]config.Profile{}}
	_, err := cfg.GetProfile("nonexistent")
	assert.Error(t, err)
}

func TestConfigHash(t *testing.T) {
	cfg := &config.Config{
		Profiles: map[string]config.Profile{
			"work": {GHConfigDir: "/tmp", GitEmail: "a@b.com"},
		},
	}

	hash1 := cfg.ConfigHash()
	assert.NotEmpty(t, hash1)

	// 동일 설정 → 동일 해시
	hash2 := cfg.ConfigHash()
	assert.Equal(t, hash1, hash2)

	// 프로필 변경 → 해시 변경
	cfg.Profiles["work"] = config.Profile{GHConfigDir: "/tmp2", GitEmail: "c@d.com"}
	hash3 := cfg.ConfigHash()
	assert.NotEqual(t, hash1, hash3)
}
```

**Step 2: 구현 (config.go에 추가)**

```go
// MatchOwner는 owner가 포함된 프로필 이름 목록을 반환한다.
func (c *Config) MatchOwner(owner string) []string {
	var matches []string
	for name, p := range c.Profiles {
		for _, o := range p.Owners {
			if o == owner {
				matches = append(matches, name)
				break
			}
		}
	}
	sort.Strings(matches)
	return matches
}

// GetProfile은 이름으로 프로필을 조회한다. 없으면 에러.
func (c *Config) GetProfile(name string) (*Profile, error) {
	p, ok := c.Profiles[name]
	if !ok {
		return nil, fmt.Errorf("config.GetProfile: 프로필 %q 없음", name)
	}
	return &p, nil
}

// ConfigHash는 profiles 섹션의 SHA-256 해시(앞 8자)를 반환한다.
func (c *Config) ConfigHash() string {
	h := sha256.New()
	keys := make([]string, 0, len(c.Profiles))
	for k := range c.Profiles {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		p := c.Profiles[k]
		fmt.Fprintf(h, "%s:%s:%s:%s:%s:%v", k, p.GHConfigDir, p.SSHHost, p.GitEmail, p.GitName, p.Owners)
	}
	return fmt.Sprintf("%x", h.Sum(nil))[:8]
}
```

**Step 3: 전체 테스트 및 커밋**

Run: `go test ./internal/config/... -v`

```bash
git add internal/config/
git commit -m "feat(config): implement Profile Store — MatchOwner, GetProfile, ConfigHash"
```

---

### Task 4: cache 패키지 — 전체 구현

**Files:**
- Create: `internal/cache/cache.go`
- Modify: `internal/cache/example_test.go`

**Refs:** TECH_SPEC §5.2 (cache.json), §11 (무효화 정책)

**Step 1: 테스트 — `internal/cache/example_test.go` 전체 교체**

```go
package cache_test

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/hbjs97/ctx/internal/cache"
	"github.com/hbjs97/ctx/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoadCache_ValidJSON(t *testing.T) {
	content := `{
		"version": 1,
		"entries": {
			"company-org/api-server": {
				"profile": "work",
				"reason": "owner_rule",
				"resolved_at": "2026-02-14T10:30:00Z",
				"config_hash": "a1b2c3d4"
			}
		}
	}`
	path := testutil.TempCacheFile(t, content)
	c, err := cache.Load(path)

	require.NoError(t, err)
	assert.Equal(t, 1, c.Version)
	assert.Len(t, c.Entries, 1)
	assert.Equal(t, "work", c.Entries["company-org/api-server"].Profile)
}

func TestLoadCache_MissingFile(t *testing.T) {
	c, err := cache.Load("/nonexistent/cache.json")
	require.NoError(t, err) // graceful: 빈 캐시 반환
	assert.Empty(t, c.Entries)
}

func TestLoadCache_InvalidJSON(t *testing.T) {
	path := testutil.TempCacheFile(t, "not json {{{")
	c, err := cache.Load(path)
	require.NoError(t, err) // graceful degradation
	assert.Empty(t, c.Entries)
}

func TestLookup_Hit(t *testing.T) {
	c := &cache.Cache{
		Entries: map[string]cache.Entry{
			"org/repo": {
				Profile:    "work",
				Reason:     "owner_rule",
				ResolvedAt: time.Now().Format(time.RFC3339),
				ConfigHash: "abc123",
			},
		},
	}
	entry, ok := c.Lookup("org/repo", "abc123", 90)
	assert.True(t, ok)
	assert.Equal(t, "work", entry.Profile)
}

func TestLookup_TTLExpired(t *testing.T) {
	c := &cache.Cache{
		Entries: map[string]cache.Entry{
			"org/repo": {
				Profile:    "work",
				ResolvedAt: time.Now().Add(-91 * 24 * time.Hour).Format(time.RFC3339),
				ConfigHash: "abc123",
			},
		},
	}
	_, ok := c.Lookup("org/repo", "abc123", 90)
	assert.False(t, ok)
}

func TestLookup_HashMismatch(t *testing.T) {
	c := &cache.Cache{
		Entries: map[string]cache.Entry{
			"org/repo": {
				Profile:    "work",
				ResolvedAt: time.Now().Format(time.RFC3339),
				ConfigHash: "old_hash",
			},
		},
	}
	_, ok := c.Lookup("org/repo", "new_hash", 90)
	assert.False(t, ok)
}

func TestSave_NewEntry(t *testing.T) {
	c := cache.New()
	c.Set("org/repo", cache.Entry{
		Profile:    "work",
		Reason:     "probe",
		ResolvedAt: time.Now().Format(time.RFC3339),
		ConfigHash: "abc",
	})

	dir := t.TempDir()
	path := filepath.Join(dir, "cache.json")
	err := c.Save(path)
	require.NoError(t, err)

	info, _ := os.Stat(path)
	assert.Equal(t, os.FileMode(0600), info.Mode().Perm())

	loaded, err := cache.Load(path)
	require.NoError(t, err)
	assert.Equal(t, "work", loaded.Entries["org/repo"].Profile)
}

func TestSave_UpdateEntry(t *testing.T) {
	c := cache.New()
	c.Set("org/repo", cache.Entry{Profile: "work", Reason: "owner_rule"})
	c.Set("org/repo", cache.Entry{Profile: "personal", Reason: "user_select"})
	assert.Equal(t, "personal", c.Entries["org/repo"].Profile)
}

func TestInvalidate_ByProfile(t *testing.T) {
	c := cache.New()
	c.Set("org/repo1", cache.Entry{Profile: "work"})
	c.Set("org/repo2", cache.Entry{Profile: "work"})
	c.Set("user/repo3", cache.Entry{Profile: "personal"})

	c.InvalidateByProfile("work")

	assert.Len(t, c.Entries, 1)
	assert.Contains(t, c.Entries, "user/repo3")
}
```

**Step 2: 구현 — `internal/cache/cache.go`**

```go
package cache

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// Cache는 리포-프로필 매핑 캐시다.
type Cache struct {
	Version int              `json:"version"`
	Entries map[string]Entry `json:"entries"`
}

// Entry는 하나의 캐시 항목이다.
type Entry struct {
	Profile    string `json:"profile"`
	Reason     string `json:"reason"`
	ResolvedAt string `json:"resolved_at"`
	ConfigHash string `json:"config_hash"`
}

// New는 빈 캐시를 생성한다.
func New() *Cache {
	return &Cache{Version: 1, Entries: make(map[string]Entry)}
}

// Load는 캐시 파일을 파싱한다. 파일 없음/파싱 실패 시 빈 캐시 반환 (graceful).
func Load(path string) (*Cache, error) {
	data, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		return New(), nil
	}
	if err != nil {
		return nil, fmt.Errorf("cache.Load: %w", err)
	}
	var c Cache
	if err := json.Unmarshal(data, &c); err != nil {
		return New(), nil
	}
	if c.Entries == nil {
		c.Entries = make(map[string]Entry)
	}
	return &c, nil
}

// Lookup은 키로 캐시를 조회한다. TTL과 config_hash가 유효해야 hit.
func (c *Cache) Lookup(key, configHash string, ttlDays int) (*Entry, bool) {
	e, ok := c.Entries[key]
	if !ok {
		return nil, false
	}
	if e.ConfigHash != configHash {
		return nil, false
	}
	resolved, err := time.Parse(time.RFC3339, e.ResolvedAt)
	if err != nil {
		return nil, false
	}
	if time.Since(resolved) > time.Duration(ttlDays)*24*time.Hour {
		return nil, false
	}
	return &e, true
}

// Set은 캐시 항목을 추가하거나 갱신한다.
func (c *Cache) Set(key string, entry Entry) {
	c.Entries[key] = entry
}

// Save는 캐시를 JSON 파일로 저장한다 (0600 권한).
func (c *Cache) Save(path string) error {
	data, err := json.MarshalIndent(c, "", "  ")
	if err != nil {
		return fmt.Errorf("cache.Save: %w", err)
	}
	if err := os.MkdirAll(filepath.Dir(path), 0700); err != nil {
		return fmt.Errorf("cache.Save: %w", err)
	}
	return os.WriteFile(path, data, 0600)
}

// InvalidateByProfile은 특정 프로필의 모든 캐시 항목을 제거한다.
func (c *Cache) InvalidateByProfile(profile string) {
	for key, entry := range c.Entries {
		if entry.Profile == profile {
			delete(c.Entries, key)
		}
	}
}
```

**Step 3: Commit**

Run: `go test ./internal/cache/... -v` → all PASS

```bash
git add internal/cache/
git commit -m "feat(cache): implement Load, Lookup, Save, InvalidateByProfile"
```

---

## Phase 2: 어댑터

### Task 5: git 패키지 — URL 파싱 (순수 함수)

**Files:**
- Create: `internal/git/git.go`
- Modify: `internal/git/example_test.go`

**Refs:** TECH_SPEC §7.2 (clone target), TESTING.md §2.3 (ParseRepoURL 예시)

**Step 1: 테이블 테스트 — `internal/git/example_test.go` 전체 교체**

```go
package git_test

import (
	"testing"

	"github.com/hbjs97/ctx/internal/git"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestParseRepoURL(t *testing.T) {
	tests := []struct {
		name    string
		input   string
		want    git.RepoRef
		wantErr bool
	}{
		{name: "ssh custom host", input: "git@github-company:company-org/api-server.git",
			want: git.RepoRef{Owner: "company-org", Repo: "api-server", Host: "github-company"}},
		{name: "ssh github.com", input: "git@github.com:hbjs97/dotfiles.git",
			want: git.RepoRef{Owner: "hbjs97", Repo: "dotfiles", Host: "github.com"}},
		{name: "https with .git", input: "https://github.com/hbjs97/dotfiles.git",
			want: git.RepoRef{Owner: "hbjs97", Repo: "dotfiles", Host: "github.com"}},
		{name: "https without .git", input: "https://github.com/hbjs97/dotfiles",
			want: git.RepoRef{Owner: "hbjs97", Repo: "dotfiles", Host: "github.com"}},
		{name: "shorthand", input: "company-org/api-server",
			want: git.RepoRef{Owner: "company-org", Repo: "api-server"}},
		{name: "invalid single word", input: "not-a-url", wantErr: true},
		{name: "empty", input: "", wantErr: true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := git.ParseRepoURL(tt.input)
			if tt.wantErr {
				assert.Error(t, err)
				return
			}
			require.NoError(t, err)
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestBuildSSHRemoteURL(t *testing.T) {
	got := git.BuildSSHRemoteURL("github-company", "company-org", "api-server")
	assert.Equal(t, "git@github-company:company-org/api-server.git", got)
}

func TestIsHTTPSRemote(t *testing.T) {
	tests := []struct {
		input string
		want  bool
	}{
		{"https://github.com/o/r.git", true},
		{"http://github.com/o/r.git", true},
		{"git@github.com:o/r.git", false},
		{"git@github-work:o/r.git", false},
	}
	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.want, git.IsHTTPSRemote(tt.input))
		})
	}
}
```

**Step 2: 구현 — `internal/git/git.go`**

```go
package git

import (
	"fmt"
	"net/url"
	"strings"
)

// RepoRef는 파싱된 리포지토리 참조다.
type RepoRef struct {
	Owner string
	Repo  string
	Host  string
}

// ParseRepoURL은 SSH/HTTPS/shorthand 형식의 리포 URL을 파싱한다.
func ParseRepoURL(raw string) (RepoRef, error) {
	if raw == "" {
		return RepoRef{}, fmt.Errorf("git.ParseRepoURL: 빈 입력")
	}
	if strings.HasPrefix(raw, "git@") {
		return parseSSH(raw)
	}
	if strings.HasPrefix(raw, "https://") || strings.HasPrefix(raw, "http://") {
		return parseHTTPS(raw)
	}
	return parseShorthand(raw)
}

func parseSSH(raw string) (RepoRef, error) {
	withoutPrefix := strings.TrimPrefix(raw, "git@")
	parts := strings.SplitN(withoutPrefix, ":", 2)
	if len(parts) != 2 {
		return RepoRef{}, fmt.Errorf("git.ParseRepoURL: 잘못된 SSH URL: %s", raw)
	}
	owner, repo, err := splitOwnerRepo(strings.TrimSuffix(parts[1], ".git"))
	if err != nil {
		return RepoRef{}, err
	}
	return RepoRef{Owner: owner, Repo: repo, Host: parts[0]}, nil
}

func parseHTTPS(raw string) (RepoRef, error) {
	u, err := url.Parse(raw)
	if err != nil {
		return RepoRef{}, fmt.Errorf("git.ParseRepoURL: %w", err)
	}
	path := strings.TrimSuffix(strings.Trim(u.Path, "/"), ".git")
	owner, repo, err := splitOwnerRepo(path)
	if err != nil {
		return RepoRef{}, err
	}
	return RepoRef{Owner: owner, Repo: repo, Host: u.Host}, nil
}

func parseShorthand(raw string) (RepoRef, error) {
	owner, repo, err := splitOwnerRepo(raw)
	if err != nil {
		return RepoRef{}, err
	}
	return RepoRef{Owner: owner, Repo: repo}, nil
}

func splitOwnerRepo(s string) (string, string, error) {
	parts := strings.SplitN(s, "/", 2)
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		return "", "", fmt.Errorf("git.ParseRepoURL: owner/repo 형식 아님: %s", s)
	}
	return parts[0], parts[1], nil
}

// BuildSSHRemoteURL은 SSH remote URL을 생성한다.
func BuildSSHRemoteURL(sshHost, owner, repo string) string {
	return fmt.Sprintf("git@%s:%s/%s.git", sshHost, owner, repo)
}

// IsHTTPSRemote는 URL이 HTTPS/HTTP인지 확인한다.
func IsHTTPSRemote(remoteURL string) bool {
	return strings.HasPrefix(remoteURL, "https://") || strings.HasPrefix(remoteURL, "http://")
}
```

**Step 3: Commit**

```bash
git add internal/git/
git commit -m "feat(git): implement URL parsing — SSH, HTTPS, shorthand"
```

---

### Task 6: git 패키지 — Adapter (Commander 기반)

**Files:**
- Modify: `internal/git/git.go` — Adapter 타입 추가
- Modify: `internal/git/example_test.go` — Adapter 테스트 추가

**Step 1: Adapter 테스트 추가**

```go
import (
	"context"
	"github.com/hbjs97/ctx/internal/testutil"
)

func TestAdapter_Clone(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("git clone", "", nil)

	a := git.NewAdapter(fake)
	err := a.Clone(context.Background(), "git@host:o/r.git", "/tmp/dest")

	assert.NoError(t, err)
	assert.True(t, fake.Called("git clone"))
}

func TestAdapter_SetLocalConfig(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("git -C", "", nil)

	a := git.NewAdapter(fake)
	err := a.SetLocalConfig(context.Background(), "/tmp/repo", "user.name", "Test")

	assert.NoError(t, err)
	assert.True(t, fake.Called("git -C"))
}

func TestAdapter_GetRemoteURL(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("git -C", "git@github-work:org/repo.git\n", nil)

	a := git.NewAdapter(fake)
	u, err := a.GetRemoteURL(context.Background(), "/tmp/repo", "origin")

	require.NoError(t, err)
	assert.Equal(t, "git@github-work:org/repo.git", u)
}
```

**Step 2: 구현 (git.go에 추가)**

```go
import (
	"context"
	"github.com/hbjs97/ctx/internal/cmdexec"
)

// Adapter는 git CLI를 Commander를 통해 실행한다.
type Adapter struct {
	cmd cmdexec.Commander
}

// NewAdapter는 새 Git Adapter를 생성한다.
func NewAdapter(cmd cmdexec.Commander) *Adapter {
	return &Adapter{cmd: cmd}
}

// Clone은 리포를 클론한다.
func (a *Adapter) Clone(ctx context.Context, remoteURL, dir string) error {
	if _, err := a.cmd.Run(ctx, "git", "clone", remoteURL, dir); err != nil {
		return fmt.Errorf("git.Clone: %w", err)
	}
	return nil
}

// SetLocalConfig는 리포 로컬 git config를 설정한다.
func (a *Adapter) SetLocalConfig(ctx context.Context, repoDir, key, value string) error {
	if _, err := a.cmd.Run(ctx, "git", "-C", repoDir, "config", "--local", key, value); err != nil {
		return fmt.Errorf("git.SetLocalConfig: %w", err)
	}
	return nil
}

// GetRemoteURL은 remote URL을 반환한다.
func (a *Adapter) GetRemoteURL(ctx context.Context, repoDir, remoteName string) (string, error) {
	out, err := a.cmd.Run(ctx, "git", "-C", repoDir, "remote", "get-url", remoteName)
	if err != nil {
		return "", fmt.Errorf("git.GetRemoteURL: %w", err)
	}
	return strings.TrimSpace(string(out)), nil
}

// SetRemoteURL은 remote URL을 변경한다.
func (a *Adapter) SetRemoteURL(ctx context.Context, repoDir, remoteName, newURL string) error {
	if _, err := a.cmd.Run(ctx, "git", "-C", repoDir, "remote", "set-url", remoteName, newURL); err != nil {
		return fmt.Errorf("git.SetRemoteURL: %w", err)
	}
	return nil
}
```

**Step 3: Commit**

```bash
git add internal/git/
git commit -m "feat(git): implement Git Adapter — Clone, Config, Remote operations"
```

---

### Task 7: gh 패키지 — 권한 Probe, 환경변수 감지

**Files:**
- Create: `internal/gh/gh.go`
- Modify: `internal/gh/example_test.go`

**Refs:** TECH_SPEC §9 (GH Adapter 상세)

**Step 1: 테스트 — `internal/gh/example_test.go` 전체 교체**

```go
package gh_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/hbjs97/ctx/internal/gh"
	"github.com/hbjs97/ctx/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestProbeRepo_PushAccess(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("gh api repos/org/repo", `{"permissions":{"push":true,"admin":false}}`, nil)

	a := gh.NewAdapter(fake)
	result, err := a.ProbeRepo(context.Background(), "/tmp/gh-work", "org", "repo")

	require.NoError(t, err)
	assert.True(t, result.HasAccess)
	assert.True(t, result.CanPush)
}

func TestProbeRepo_ReadOnly(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("gh api repos/org/repo", `{"permissions":{"push":false}}`, nil)

	a := gh.NewAdapter(fake)
	result, err := a.ProbeRepo(context.Background(), "/tmp/gh-work", "org", "repo")

	require.NoError(t, err)
	assert.True(t, result.HasAccess)
	assert.False(t, result.CanPush)
}

func TestProbeRepo_NotFound(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("gh api repos/org/repo", "", fmt.Errorf("HTTP 404: Not Found"))

	a := gh.NewAdapter(fake)
	result, err := a.ProbeRepo(context.Background(), "/tmp/gh-work", "org", "repo")

	require.NoError(t, err)
	assert.False(t, result.HasAccess)
}

func TestProbeRepo_Unauthorized(t *testing.T) {
	fake := testutil.NewFakeCommander()
	fake.Register("gh api repos/org/repo", "", fmt.Errorf("HTTP 401"))

	a := gh.NewAdapter(fake)
	result, err := a.ProbeRepo(context.Background(), "/tmp/gh-work", "org", "repo")

	require.NoError(t, err)
	assert.False(t, result.HasAccess)
}

func TestProbeAllProfiles(t *testing.T) {
	fake := testutil.NewFakeCommander()
	// work은 push 가능, personal은 404
	fake.Register("gh api repos/org/repo --hostname github.com --jq .permissions", "", nil)
	// 프로필별로 GH_CONFIG_DIR을 환경변수로 설정해서 호출하므로, 간단히 default로 처리
	fake.DefaultResponse = &testutil.Response{
		Output: []byte(`{"permissions":{"push":true}}`),
	}

	a := gh.NewAdapter(fake)
	profiles := map[string]string{
		"work":     "/tmp/gh-work",
		"personal": "/tmp/gh-personal",
	}
	results, err := a.ProbeAllProfiles(context.Background(), "org", "repo", profiles)

	require.NoError(t, err)
	assert.Len(t, results, 2)
}

func TestDetectEnvTokenInterference(t *testing.T) {
	t.Setenv("GH_TOKEN", "")
	t.Setenv("GITHUB_TOKEN", "")
	_, found := gh.DetectEnvTokenInterference()
	assert.False(t, found)

	t.Setenv("GH_TOKEN", "ghp_test123")
	key, found := gh.DetectEnvTokenInterference()
	assert.True(t, found)
	assert.Equal(t, "GH_TOKEN", key)
}
```

**Step 2: 구현 — `internal/gh/gh.go`**

```go
package gh

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/hbjs97/ctx/internal/cmdexec"
)

// ProbeResult는 권한 probe 결과다.
type ProbeResult struct {
	Profile   string
	HasAccess bool
	CanPush   bool
}

// Adapter는 gh CLI를 Commander를 통해 실행한다.
type Adapter struct {
	cmd cmdexec.Commander
}

// NewAdapter는 새 GH Adapter를 생성한다.
func NewAdapter(cmd cmdexec.Commander) *Adapter {
	return &Adapter{cmd: cmd}
}

// ProbeRepo는 특정 프로필로 리포의 접근 권한을 확인한다.
func (a *Adapter) ProbeRepo(ctx context.Context, ghConfigDir, owner, repo string) (*ProbeResult, error) {
	out, err := a.cmd.Run(ctx, "gh", "api",
		fmt.Sprintf("repos/%s/%s", owner, repo),
		"--hostname", "github.com",
		"--jq", ".permissions")

	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "404") || strings.Contains(errStr, "403") || strings.Contains(errStr, "401") {
			return &ProbeResult{HasAccess: false}, nil
		}
		return nil, fmt.Errorf("gh.ProbeRepo: %w", err)
	}

	var perms struct {
		Push  bool `json:"push"`
		Admin bool `json:"admin"`
	}
	if err := json.Unmarshal(out, &perms); err != nil {
		return nil, fmt.Errorf("gh.ProbeRepo: JSON 파싱 실패: %w", err)
	}
	return &ProbeResult{HasAccess: true, CanPush: perms.Push}, nil
}

// ProbeAllProfiles는 모든 프로필로 리포를 probe한다.
// profiles: map[profileName]ghConfigDir
func (a *Adapter) ProbeAllProfiles(ctx context.Context, owner, repo string, profiles map[string]string) ([]ProbeResult, error) {
	var results []ProbeResult
	for name, dir := range profiles {
		result, err := a.ProbeRepo(ctx, dir, owner, repo)
		if err != nil {
			return nil, fmt.Errorf("gh.ProbeAllProfiles[%s]: %w", name, err)
		}
		result.Profile = name
		results = append(results, *result)
	}
	return results, nil
}

// DetectEnvTokenInterference는 GH_TOKEN/GITHUB_TOKEN 환경변수를 감지한다.
func DetectEnvTokenInterference() (string, bool) {
	for _, key := range []string{"GH_TOKEN", "GITHUB_TOKEN"} {
		if os.Getenv(key) != "" {
			return key, true
		}
	}
	return "", false
}
```

**Step 3: Commit**

```bash
git add internal/gh/
git commit -m "feat(gh): implement GH Adapter — ProbeRepo, ProbeAllProfiles, env detection"
```

---

## Phase 3: 코어 엔진

### Task 8: resolver 패키지 — 5단계 판정 파이프라인

**Files:**
- Create: `internal/resolver/resolver.go`
- Modify: `internal/resolver/example_test.go`

**Refs:** TECH_SPEC §6 (Resolver 상세), TESTING.md §3.3 (통합 시나리오 12개)

**Step 1: 테스트 헬퍼 + Step 1-3 테스트**

`internal/resolver/example_test.go` 전체 교체:

```go
package resolver_test

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/hbjs97/ctx/internal/cache"
	"github.com/hbjs97/ctx/internal/config"
	"github.com/hbjs97/ctx/internal/gh"
	"github.com/hbjs97/ctx/internal/git"
	"github.com/hbjs97/ctx/internal/resolver"
	"github.com/hbjs97/ctx/internal/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func testConfig() *config.Config {
	return &config.Config{
		CacheTTLDays: 90,
		Profiles: map[string]config.Profile{
			"work": {
				GHConfigDir: "/tmp/gh-work", SSHHost: "github-work",
				GitName: "W", GitEmail: "w@co.com", Owners: []string{"company-org"},
			},
			"personal": {
				GHConfigDir: "/tmp/gh-personal", SSHHost: "github-personal",
				GitName: "P", GitEmail: "p@me.com", Owners: []string{"hbjs97"},
			},
		},
	}
}

// Step 1: 명시 플래그
func TestResolve_ExplicitFlag(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	result, err := r.Resolve(context.Background(), "any/repo", "work")
	require.NoError(t, err)
	assert.Equal(t, "work", result.Profile)
	assert.Equal(t, "explicit", result.Reason)
}

func TestResolve_ExplicitFlag_NotExists(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	_, err := r.Resolve(context.Background(), "any/repo", "nonexist")
	assert.Error(t, err)
}

// Step 2: 캐시
func TestResolve_CacheHit(t *testing.T) {
	cfg := testConfig()
	c := cache.New()
	c.Set("company-org/api", cache.Entry{
		Profile: "work", Reason: "owner_rule",
		ResolvedAt: time.Now().Format(time.RFC3339), ConfigHash: cfg.ConfigHash(),
	})
	fake := testutil.NewFakeCommander()
	r := resolver.New(cfg, c, git.NewAdapter(fake), gh.NewAdapter(fake), false)

	result, err := r.Resolve(context.Background(), "company-org/api", "")
	require.NoError(t, err)
	assert.Equal(t, "work", result.Profile)
	assert.Equal(t, "cache", result.Reason)
}

func TestResolve_CacheTTLExpired(t *testing.T) {
	cfg := testConfig()
	c := cache.New()
	c.Set("company-org/api", cache.Entry{
		Profile: "work", Reason: "owner_rule",
		ResolvedAt: time.Now().Add(-91 * 24 * time.Hour).Format(time.RFC3339),
		ConfigHash: cfg.ConfigHash(),
	})
	fake := testutil.NewFakeCommander()
	// owner rule이 잡아야 함
	r := resolver.New(cfg, c, git.NewAdapter(fake), gh.NewAdapter(fake), false)

	result, err := r.Resolve(context.Background(), "company-org/api", "")
	require.NoError(t, err)
	assert.Equal(t, "owner_rule", result.Reason) // 캐시 미스 → Step 3
}

func TestResolve_CacheHashMismatch(t *testing.T) {
	cfg := testConfig()
	c := cache.New()
	c.Set("company-org/api", cache.Entry{
		Profile: "work", Reason: "owner_rule",
		ResolvedAt: time.Now().Format(time.RFC3339), ConfigHash: "stale_hash",
	})
	fake := testutil.NewFakeCommander()
	r := resolver.New(cfg, c, git.NewAdapter(fake), gh.NewAdapter(fake), false)

	result, err := r.Resolve(context.Background(), "company-org/api", "")
	require.NoError(t, err)
	assert.Equal(t, "owner_rule", result.Reason)
}

// Step 3: Owner 규칙
func TestResolve_OwnerRuleSingleMatch(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	result, err := r.Resolve(context.Background(), "company-org/api", "")
	require.NoError(t, err)
	assert.Equal(t, "work", result.Profile)
	assert.Equal(t, "owner_rule", result.Reason)
}

func TestResolve_OwnerRuleNoMatch(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	// unknown owner → probe로 전이. probe도 실패 설정
	fake.DefaultResponse = &testutil.Response{Err: fmt.Errorf("HTTP 404")}
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	_, err := r.Resolve(context.Background(), "unknown-org/repo", "")
	assert.Error(t, err) // 접근 불가
}

func TestResolve_OwnerRuleMultipleMatch(t *testing.T) {
	cfg := testConfig()
	cfg.Profiles["personal"] = config.Profile{
		GHConfigDir: "/tmp/gh-p", SSHHost: "gh-p",
		GitName: "P", GitEmail: "p@p.com",
		Owners: []string{"company-org"}, // 양쪽에 같은 owner
	}
	fake := testutil.NewFakeCommander()
	fake.DefaultResponse = &testutil.Response{Err: fmt.Errorf("HTTP 404")}
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	_, err := r.Resolve(context.Background(), "company-org/repo", "")
	assert.Error(t, err) // probe로 전이 후 실패
}

// Step 4: Probe
func TestResolve_ProbeSinglePush(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	fake.DefaultResponse = &testutil.Response{
		Output: []byte(`{"permissions":{"push":false}}`),
	}
	// work 프로필만 push 가능하도록 설정
	fake.Register("gh api repos/unknown/repo --hostname github.com --jq .permissions",
		`{"permissions":{"push":true}}`, nil)

	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)
	result, err := r.Resolve(context.Background(), "unknown/repo", "")

	require.NoError(t, err)
	assert.Equal(t, "probe", result.Reason)
}

func TestResolve_ProbeNoPush(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	fake.DefaultResponse = &testutil.Response{Err: fmt.Errorf("HTTP 404")}
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	_, err := r.Resolve(context.Background(), "private-org/repo", "")
	assert.Error(t, err) // exit code 4
}

// Step 5: 비대화형 모호
func TestResolve_ProbeMultiplePush_NonInteractive(t *testing.T) {
	cfg := testConfig()
	fake := testutil.NewFakeCommander()
	fake.DefaultResponse = &testutil.Response{
		Output: []byte(`{"permissions":{"push":true}}`),
	}
	r := resolver.New(cfg, cache.New(), git.NewAdapter(fake), gh.NewAdapter(fake), false)

	_, err := r.Resolve(context.Background(), "shared/repo", "")
	assert.Error(t, err) // exit code 3
}
```

**Step 2: 구현 — `internal/resolver/resolver.go`**

```go
package resolver

import (
	"context"
	"fmt"
	"strings"

	"github.com/hbjs97/ctx/internal/cache"
	"github.com/hbjs97/ctx/internal/config"
	"github.com/hbjs97/ctx/internal/gh"
	"github.com/hbjs97/ctx/internal/git"
)

// Result는 Resolver의 판정 결과다.
type Result struct {
	Profile string
	Reason  string // "explicit", "cache", "owner_rule", "probe", "user_select"
}

// Resolver는 5단계 계정 판정 파이프라인이다.
type Resolver struct {
	config      *config.Config
	cache       *cache.Cache
	git         *git.Adapter
	gh          *gh.Adapter
	interactive bool
}

// New는 새 Resolver를 생성한다.
func New(cfg *config.Config, c *cache.Cache, g *git.Adapter, h *gh.Adapter, interactive bool) *Resolver {
	return &Resolver{config: cfg, cache: c, git: g, gh: h, interactive: interactive}
}

// Resolve는 5단계 파이프라인으로 프로필을 판정한다.
func (r *Resolver) Resolve(ctx context.Context, ownerRepo, explicitProfile string) (*Result, error) {
	// Step 1: 명시 플래그
	if explicitProfile != "" {
		if _, err := r.config.GetProfile(explicitProfile); err != nil {
			return nil, fmt.Errorf("resolver.Resolve: %w", err)
		}
		return &Result{Profile: explicitProfile, Reason: "explicit"}, nil
	}

	// Step 2: 캐시 조회
	configHash := r.config.ConfigHash()
	if entry, ok := r.cache.Lookup(ownerRepo, configHash, r.config.CacheTTLDays); ok {
		return &Result{Profile: entry.Profile, Reason: "cache"}, nil
	}

	// Step 3: Owner 규칙
	owner := strings.SplitN(ownerRepo, "/", 2)[0]
	matches := r.config.MatchOwner(owner)
	if len(matches) == 1 {
		return &Result{Profile: matches[0], Reason: "owner_rule"}, nil
	}

	// Step 4: 권한 Probe
	profileDirs := make(map[string]string)
	for name, p := range r.config.Profiles {
		profileDirs[name] = p.GHConfigDir
	}
	parts := strings.SplitN(ownerRepo, "/", 2)
	if len(parts) != 2 {
		return nil, fmt.Errorf("resolver.Resolve: 잘못된 owner/repo: %s", ownerRepo)
	}
	probeResults, err := r.gh.ProbeAllProfiles(ctx, parts[0], parts[1], profileDirs)
	if err != nil {
		return nil, fmt.Errorf("resolver.Resolve: %w", err)
	}

	var pushable []ProbeHit
	for _, pr := range probeResults {
		if pr.CanPush {
			pushable = append(pushable, ProbeHit{Profile: pr.Profile})
		}
	}

	if len(pushable) == 1 {
		return &Result{Profile: pushable[0].Profile, Reason: "probe"}, nil
	}
	if len(pushable) == 0 {
		return nil, fmt.Errorf("resolver.Resolve: 접근 가능한 프로필 없음")
	}

	// Step 5: 사용자 선택
	if !r.interactive {
		return nil, fmt.Errorf("resolver.Resolve: 모호한 판정, --profile 플래그 필요")
	}
	// 대화형 선택은 CLI 레이어에서 콜백으로 처리 (향후 확장)
	return nil, fmt.Errorf("resolver.Resolve: 사용자 선택 필요")
}

// ProbeHit은 probe에서 push 가능한 프로필이다.
type ProbeHit struct {
	Profile string
}
```

**Step 3: Commit**

```bash
git add internal/resolver/
git commit -m "feat(resolver): implement 5-step resolution pipeline"
```

---

## Phase 4: 안전 & 통합

### Task 9: guard 패키지 — 컨텍스트 검사 + Hook 관리

**Files:**
- Create: `internal/guard/guard.go`
- Modify: `internal/guard/example_test.go`

**Refs:** TECH_SPEC §8 (Guard Engine)

**테스트 목록 (example_test.go 전체 교체):**
- `TestCheck_AllMatch` — 모두 일치 → pass
- `TestCheck_RemoteHostMismatch` — SSH host 불일치 → 차단
- `TestCheck_EmailMismatch` — email 불일치 → 차단
- `TestCheck_NameMismatch` — name 불일치 → 경고 (차단 아님)
- `TestCheck_NoCtxProfile` — .git/ctx-profile 없음 → 에러
- `TestCheck_SkipGuardEnv` — CTX_SKIP_GUARD=1 → 우회
- `TestInstallHook_NoExisting` — 새 hook 생성
- `TestInstallHook_ExistingHook` — 기존 hook 체이닝
- `TestUninstallHook` — 마커 사이 제거

**핵심 타입:**

```go
type CheckResult struct {
	Pass       bool
	Violations []Violation
}

type Violation struct {
	Field    string // "remote_host", "user_email", "user_name"
	Expected string
	Actual   string
	Severity string // "error", "warning"
}
```

**핵심 함수:** `Check(ctx, repoDir, cfg, cmd)`, `InstallHook(repoDir, cmd)`, `UninstallHook(repoDir)`

Guard는 `.git/ctx-profile` 읽기 → config에서 프로필 조회 → remote host/email/name 비교 → Violation 목록 반환. `InstallHook`은 `# ctx-guard-start` / `# ctx-guard-end` 마커로 hook 삽입. 기존 hook은 `.ctx-backup`으로 백업 후 체이닝.

**Commit:**

```bash
git add internal/guard/
git commit -m "feat(guard): implement pre-push check and hook management"
```

---

### Task 10: shell 패키지 — activate + hook 스니펫

**Files:**
- Create: `internal/shell/shell.go`
- Create: `internal/shell/shell_test.go`

**Refs:** TECH_SPEC §10 (Shell Integration)

**테스트 목록:**
- `TestActivate_ManagedRepo` — 프로필 있는 리포 → export GH_CONFIG_DIR, CTX_PROFILE
- `TestActivate_DefaultProfile` — 리포 밖, default_profile 설정됨 → default 프로필
- `TestActivate_NoProfile` — 리포 밖, default 없음 → unset
- `TestActivate_Fish` — Fish shell 형식 출력
- `TestHookSnippet_Zsh` — chpwd_functions 스니펫
- `TestHookSnippet_Bash` — PROMPT_COMMAND 스니펫
- `TestHookSnippet_Fish` — --on-variable PWD 스니펫

**핵심 함수:** `Activate(profileName, cfg, shellType) string`, `HookSnippet(shellType) string`

**Commit:**

```bash
git add internal/shell/
git commit -m "feat(shell): implement activate and shell hook snippets"
```

---

### Task 11: doctor 패키지 — 환경 진단

**Files:**
- Create: `internal/doctor/doctor.go`
- Modify: `internal/doctor/example_test.go`

**Refs:** TECH_SPEC §7.5 (8개 점검 항목)

**테스트 목록:**
- `TestCheckBinaries_AllPresent` — git/gh/ssh 모두 존재 → OK
- `TestCheckBinaries_Missing` — 누락 → FAIL + 설치 안내
- `TestCheckGHAuth_Authenticated` — gh auth status 성공 → OK
- `TestCheckGHAuth_NotAuthenticated` — 실패 → FAIL + "gh auth login" 안내
- `TestCheckSSHConnection` — ssh -T 성공/실패
- `TestCheckEnvTokens` — GH_TOKEN 감지 → WARN
- `TestCheckConfigValidity` — config.toml 유효/무효
- `TestRunAll` — 모든 점검 통합

**핵심 타입:** `Status` (OK/WARN/FAIL), `CheckResult{Name, Status, Message, Fix}`
**핵심 함수:** `CheckBinaries`, `CheckGHAuth`, `CheckSSH`, `CheckEnvTokens`, `CheckConfig`, `RunAll`

**Commit:**

```bash
git add internal/doctor/
git commit -m "feat(doctor): implement environment diagnostics"
```

---

## Phase 5: CLI & 엔트리포인트

### Task 12: cli 패키지 — cobra 프레임워크 + 전체 명령

**Files:**
- Create: `internal/cli/root.go`
- Create: `internal/cli/clone.go`
- Create: `internal/cli/init_cmd.go` (init은 Go 예약어이므로 파일명 주의)
- Create: `internal/cli/status.go`
- Create: `internal/cli/doctor.go`
- Create: `internal/cli/guard.go`
- Create: `internal/cli/activate.go`
- Create: `internal/cli/exitcode.go`
- Modify: `internal/cli/example_test.go`

**Step 1: cobra 의존성 추가**

```bash
go get github.com/spf13/cobra
```

**Step 2: 에러 코드 (exitcode.go)**

```go
package cli

// ExitCode는 ctx의 종료 코드다. TECH_SPEC §12 참조.
type ExitCode int

const (
	ExitSuccess      ExitCode = 0
	ExitGeneral      ExitCode = 1
	ExitGuardBlock   ExitCode = 2
	ExitAmbiguous    ExitCode = 3
	ExitAuthFail     ExitCode = 4
	ExitConfigError  ExitCode = 5
	ExitNoDependency ExitCode = 6
)
```

**Step 3: Root 명령 (root.go)**

```go
func NewRootCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "ctx",
		Short: "GitHub 멀티계정 컨텍스트 매니저",
		SilenceUsage: true,
	}
	cmd.AddCommand(
		newCloneCmd(), newInitCmd(), newStatusCmd(),
		newDoctorCmd(), newGuardCmd(), newActivateCmd(),
	)
	return cmd
}
```

**Step 4: 각 서브커맨드 구현**

각 커맨드는 동일 패턴: config/cache 로드 → Commander 생성 → 도메인 로직 호출 → 결과 출력.

**clone.go 핵심 흐름:**
1. `git.ParseRepoURL(target)` → owner/repo 추출
2. `config.Load`, `cache.Load`
3. `resolver.New(...).Resolve(ctx, ownerRepo, profileFlag)`
4. `git.BuildSSHRemoteURL` → `gitAdapter.Clone`
5. `gitAdapter.SetLocalConfig` (user.name, user.email)
6. `.git/ctx-profile` 기록
7. `guard.InstallHook` (--no-guard 아닌 경우)
8. 캐시 저장, 결과 출력

**init_cmd.go 핵심 흐름:**
1. 현재 디렉토리가 git 리포인지 확인
2. `gitAdapter.GetRemoteURL` → `git.ParseRepoURL`
3. resolver 실행
4. HTTPS → SSH 변환 제안 (allow_https_managed_repo 설정에 따라)
5. git identity 설정, ctx-profile 기록, guard 설치, 캐시 저장

**status.go 핵심 흐름:**
1. `.git/ctx-profile` 읽기 (없으면 "ctx init 안내")
2. config/cache에서 프로필 정보 조회
3. git remote, user.name, user.email 현재값 조회
4. 불일치 항목 교차 검증
5. `--json` 플래그 시 JSON 출력

**doctor.go:** `doctor.RunAll` 호출 후 결과 포매팅

**guard.go:** `ctx guard check` → `guard.Check` 호출

**activate.go:** `ctx activate --shell zsh` → `shell.Activate` 호출

**Step 5: Commit**

```bash
git add internal/cli/
git commit -m "feat(cli): implement cobra commands — clone, init, status, doctor, guard, activate"
```

---

### Task 13: cmd/ctx — 메인 엔트리포인트

**Files:**
- Modify: `cmd/ctx/main.go`

**Step 1: 구현**

```go
package main

import (
	"os"

	"github.com/hbjs97/ctx/internal/cli"
)

func main() {
	cmd := cli.NewRootCmd()
	if err := cmd.Execute(); err != nil {
		os.Exit(int(cli.MapExitCode(err)))
	}
}
```

**Step 2: 빌드 확인**

```bash
go build -o bin/ctx ./cmd/ctx && ./bin/ctx --help
```
Expected: ctx 도움말 출력

**Step 3: 전체 검증**

```bash
make test        # 전체 테스트
go vet ./...     # 정적 분석
make coverage    # 커버리지 80%+ 확인
make test-race   # race condition 검사
```

**Step 4: Commit**

```bash
git add cmd/ctx/main.go
git commit -m "feat: wire main entrypoint with cobra CLI"
```

---

## 구현 순서 요약

```
Pre-Task: Commander → cmdexec 추출
Task  1: 의존성 추가 (toml, testify)
Task  2: config — Load, 기본값, 유효성       ← Phase 1 시작
Task  3: config — Profile Store
Task  4: cache — 전체 구현
Task  5: git — URL 파싱                      ← Phase 2 시작
Task  6: git — Adapter
Task  7: gh — Probe, 환경변수 감지
Task  8: resolver — 5단계 파이프라인          ← Phase 3
Task  9: guard — Check, Hook 관리            ← Phase 4 시작
Task 10: shell — activate, hook 스니펫
Task 11: doctor — 환경 진단
Task 12: cli — cobra + 전체 명령             ← Phase 5 시작
Task 13: cmd/ctx — 엔트리포인트

cobra 의존성: Task 12에서 추가 (go get github.com/spf13/cobra)
```

## 의존성 그래프

```
cmdexec ← (모든 adapter/engine 패키지)
config  ← cache, resolver, guard, shell, doctor, cli
cache   ← resolver, cli
git     ← resolver, guard, cli
gh      ← resolver, cli
resolver ← cli
guard   ← cli
shell   ← cli
doctor  ← cli
cli     ← cmd/ctx
```

## 완료 기준

- [ ] `go build ./...` — 빌드 성공
- [ ] `go test ./...` — 전체 테스트 통과
- [ ] `go vet ./...` — 경고 없음
- [ ] `make coverage` — 80%+ (resolver, guard는 90%+)
- [ ] `make test-race` — race condition 없음
- [ ] `./bin/ctx --help` — 전체 명령 표시
- [ ] `./bin/ctx clone org/repo` — 정상 동작 (실제 환경)
- [ ] `./bin/ctx status` — 상태 출력
- [ ] `./bin/ctx doctor` — 진단 결과 출력
